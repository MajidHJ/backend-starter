## Day 44 Report

### Objectives

* Introduce **Application Layer** into the project structure.
* Establish clear separation between **HTTP layer (API)** and **Use-case logic**.
* Prepare the codebase for gradual refactoring of CRUD logic from routes to services (Week 7 goal).
* Inject `UserService` into routes using dependency injection.
* Move pagination logic from route to service to reinforce layering.

---

### What I Learned

* **Application Layer purpose**:
  It hosts use-cases and orchestration logic, independent of FastAPI and HTTP concerns.

* **Route vs Service responsibility**:

  * Route → HTTP mapping (Query params, status codes, response models).
  * Service → Business workflow and use-case execution.

* **Dependency Injection (basic form)**:

  * Service should receive dependencies (e.g., storage) instead of importing them.
  * Avoid direct coupling between API layer and storage.

* **Stateless vs Stateful Service**:

  * Services should ideally be stateless.
  * Lifecycle (singleton vs per-request) should not affect business correctness.

* **Pagination placement**:

  * HTTP validation (`Query(ge=1, le=50)`) stays in route.
  * Pagination logic (offset calculation, slicing, total count) belongs in service.

* **Educational Trade-offs**:

  * Using in-memory `fake_users_` as shared storage.
  * Using schema models (`Page`, `UserResponse`) directly in service.
  * No domain errors or repository abstraction yet.

---

### Project Structure (Up to Day 44)

```
app/
│
├── main.py
│
├── api/
│   └── v1/
│       └── users.py          # HTTP layer (routes only)
│
├── schemas/
│   ├── user.py               # User DTOs
│   └── common.py             # Page[T], ErrorResponse
│
├── application/
│   └── users/
│       └── service.py        # User use-cases (Application Layer)
│
└── (temporary in-memory storage inside users.py)
```

---

### Architectural State

* API layer no longer owns business logic.
* Use-case logic is centralized in `UserService`.
* Pagination and orchestration moved toward Application layer.
* Foundation prepared for:

  * Repository abstraction
  * Domain errors
  * Database integration
  * Proper DI refinement
